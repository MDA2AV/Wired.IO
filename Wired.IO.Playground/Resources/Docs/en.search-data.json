{"/docs/":{"data":{"":"Wired.IO is a high-performance, embeddable HTTP server for .NET. Built for developers who need full control and minimal overhead, it integrates seamlessly with the IHost model, making it ideal for microservices, embedded control panels, and custom protocol handlers. Use the built-in HTTP/1.1 support out of the box, or implement your own handler to take full control of the wire. This documentation covers everything you need to get started — from setup and configuration to extending the pipeline and handling requests your way."},"title":"Documentation"},"/docs/create-a-builder/":{"data":{"":"","#":"In this section you will learn how to create a builder using the default or a custom handler.\nHandlers are responsible of receiving the request, parse it and build the context that can be used in the endpoint logic to properly handle the request.\nCheck out Types section to learn more about this context.\nBuilder Configurability // Create a default builder var builder = WiredApp.CreateBuilder(); builder // Sets the port number .Port(5000) // Sets IPAddress and Port .Endpoint( ... ) // Sets the backlog (max number of concurrent connection) .Backlog(128) // Define TLS options // See 8 Security (TLS) .UseTls( ... ) // Register all handlers in the IServiceConnection // See 2.2 Mediator Endpoints .AddHandlers( ... ) // Register wired event disptacher to the IServiceCollection .AddWiredEvents() // Do not automatically dispatch context wired events .AddWiredEvents(false) // Register custom middleware // See 3. Adding Middleware .UseMiddleware( ... ) // Register fast endpoints .MapGet( ... ) .MapPost( ... ) .MapPut( ... ) .MapDelete( ... ) .MapPatch( ... ) .MapHead( ... ) .MapOptions( ... ) "},"title":"Create a Builder"},"/docs/create-a-builder/custom-handler/":{"data":{"":"","#":"You can roll your own IHttpHandler and injecting it when creating the builder.\nCreate a custom handler Fulfill the IHttpHandler contract\nStream stream : The NetworkStream or SslStream if TLS is enabled.\nFunc\u003cTContext, Task\u003e pipeline : The pipeline that will call the middleware pipeline and route/call the endpoint, when pipeline is invoked, the route should be already set in the TContext.\n/// \u003csummary\u003e /// Defines a contract for handling client connections using a custom or HTTP-based protocol. /// \u003c/summary\u003e public interface IHttpHandler\u003cout TContext\u003e where TContext : IContext { /// \u003csummary\u003e /// Processes a client connection and dispatches one or more protocol-compliant requests. /// \u003c/summary\u003e /// \u003cparam name=\"stream\"\u003eThe \u003csee cref=\"Stream\"/\u003e representing the client connection.\u003c/param\u003e /// \u003cparam name=\"pipeline\"\u003e /// A delegate that executes the application's request-handling pipeline, typically consisting of middleware and endpoint logic. /// \u003c/param\u003e /// \u003cparam name=\"stoppingToken\"\u003e /// A \u003csee cref=\"CancellationToken\"/\u003e used to signal cancellation, such as during server shutdown. /// \u003c/param\u003e /// \u003creturns\u003e /// A \u003csee cref=\"Task\"/\u003e that represents the asynchronous operation of handling the client session. /// \u003c/returns\u003e Task HandleClientAsync( Stream stream, Func\u003cTContext, Task\u003e pipeline, CancellationToken stoppingToken); } Custom handler pseudo example public class CustomContext : IContext { // Implement your custom IContext.. } public class CustomRequest : IRequest { // Implement your custom IRequest.. } public class CustomResponse : IResponse { // Implement your custom IResponse.. } public class CustomHttpHandler\u003cTContext\u003e : IHttpHandler\u003cTContext\u003e where TContext : class, IContext, new() { // Pool context objects for less memory pressure (optional) private static readonly ObjectPool\u003cTContext\u003e ContextPool = new DefaultObjectPool\u003cTContext\u003e(new DefaultPooledObjectPolicy\u003cTContext\u003e(), 8192); public async Task HandleClientAsync(Stream stream, Func\u003cTContext, Task\u003e pipeline, CancellationToken stoppingToken) { // Get a context object from pool (or create a new instance if not pooling) var context = ContextPool.Get(); // Create a new IHttpRequest or use pooling context.Request = new CustomRequest(); // Set up the PipeReader and PipeWriter for the context. // You can also skip this and use the Stream directly to read and write from socket. // However, the preferred way is to use PipeReader and PipeWriter for better performance. // Also, if you decide to use Stream, you will need to cast the IContext passed to the endpoint // since IContext does not expose the Stream directly. context.Reader = PipeReader.Create(stream, new StreamPipeReaderOptions(MemoryPool\u003cbyte\u003e.Shared, leaveOpen: true, bufferSize: 8192)); context.Writer = PipeWriter.Create(stream, new StreamPipeWriterOptions(MemoryPool\u003cbyte\u003e.Shared, leaveOpen: true)); // The next section is typically wrapped in a loop or equivalent if the connection is persistent (keep-alive). // Read the received request headers and set the context's HttpMethod and Route // Call the pipeline callback, it will trigger the middleware pipeline and the endpoint // Handle Keep-Alive connections // Make sure to dispose managed resources and return the context to the pool } } Injecting the custom handler in the builder Use the handler factory overload to pass the custom handler construction delegate to the CreateBuilder method.\nvar builder = WiredApp.CreateBuilder\u003cCustomHttpHandler\u003cCustomContext\u003e, CustomContext\u003e(() =\u003e new CustomHttpHandler\u003cCustomContext\u003e()); Optionally, also pass the accepted SslAplicationProtocols\nvar builder = WiredApp.CreateBuilder\u003cCustomHttpHandler\u003cCustomContext\u003e, CustomContext\u003e(() =\u003e new CustomHttpHandler\u003cCustomContext\u003e(), [SslApplicationProtocol.Http11]); "},"title":"Custom Handler"},"/docs/create-a-builder/default-handler/":{"data":{"":"","#":"By creating a builder with default handler, the inbuilt HTTP/1.1 protocol handler is set with default parameters.\nusing Wired.IO.App; var builder = WiredApp.CreateBuilder(); Inject IHandlerArgs (default values) By passing UseResources: false, ResourcesPath and ResourcesAssembly will not be considered.\nCheck Resource Hosting section to learn more about these parameters.\nLearn more about HandlerType\nusing Wired.IO.App; using Wired.IO.Protocol.Handlers; using Wired.IO.Http11.Context; var builderWithParameters = WiredApp.CreateBuilder(() =\u003e new WiredHttp11\u003cHttp11Context\u003e(new Http11HandlerArgs( UseResources: false, ResourcesPath: null!, ResourcesAssembly: null!, HandlerType: Http11HandlerType.Blocking)) ); Inject accepted SslApplicationProtocols For the default handler case, SslApplicationProtocol.Http11 will be considered by default, but that configuration can be overriden by injecting it in the CreateBuilder method.\nusing Wired.IO.App; using System.Net.Security; var builderWithSslApplicationProtocols = WiredApp.CreateBuilder([SslApplicationProtocol.Http11]); Inject IHandlerArgs and accepted SslApplicationProtocols using Wired.IO.App; using Wired.IO.Protocol.Handlers; using Wired.IO.Http11.Context; using System.Net.Security; var builder = WiredApp.CreateBuilder(() =\u003e new WiredHttp11\u003cHttp11Context\u003e(new Http11HandlerArgs( UseResources: false, ResourcesPath: null!, ResourcesAssembly: null!, HandlerType: Http11HandlerType.Blocking)), [SslApplicationProtocol.Http11] ); "},"title":"Default Handler"},"/docs/create-a-builder/default-handler/http11handlerargs/":{"data":{"":"","declaration#Declaration":"","declaration-1#Declaration":"","example#Example":"","http11handlertype#Http11HandlerType":"","parameters#Parameters":"","use-case-comparison#Use Case Comparison":"Http11HandlerArgs is a configuration record used to initialize the HTTP/1.1 handler in Wired.IO.\nIt allows you to control how HTTP/1.1 requests are handled — including static file serving and processing mode (blocking vs. non-blocking).\nDeclaration public record Http11HandlerArgs( bool UseResources, string ResourcesPath, Assembly ResourcesAssembly, Http11HandlerType HandlerType = Http11HandlerType.Blocking ) : IHandlerArgs; Parameters Parameter Type Description UseResources bool Indicates whether to serve static files from embedded resources. ResourcesPath string The virtual path prefix used to locate resources (e.g., \"MyAssemblyName\"). ResourcesAssembly Assembly The assembly containing embedded resources to serve (e.g., typeof(Program).Assembly). HandlerType Http11HandlerType Defines the handler’s processing mode: Blocking or NonBlocking. Defaults to Blocking. Example var handlerArgs = new Http11HandlerArgs( UseResources: true, ResourcesPath: \"/assets\", ResourcesAssembly: typeof(Program).Assembly, HandlerType: Http11HandlerType.NonBlocking ); Http11HandlerTypeThe Http11HandlerType enum defines how the HTTP/1.1 handler processes incoming requests over a persistent connection. Defaults to Blocking, the expected behavior for a Http/1.1 as the webserver only accepts new incoming request after finishing the previous one, if NonBlocking is selected the webserver will start handling new requests without waiting for the previous requests to finish, this can lead to issue as the order that responses are written will not be ordered, use at your own caution preferably when response is not important.\nDeclaration public enum Http11HandlerType { Blocking, NonBlocking } Values Name Description Blocking Handles requests one at a time, waiting for each response to complete before reading the next request. Ensures strict ordering and simplicity. NonBlocking Reads and processes pipelined requests concurrently. Improves throughput but requires careful management to preserve response order (if needed). Use Case Comparison Feature Blocking NonBlocking Request concurrency ❌ (sequential) ✅ (concurrent) Simplicity ✅ ❌ (requires async pipeline control) Response order guarantee ✅ ❌ (unless explicitly managed) Best for Simpler systems High-throughput, pipelined clients ","values#Values":""},"title":"Http11HandlerArgs"},"/docs/create-an-endpoint/":{"data":{"":"","#":"To create endpoints there are three different options.\nFast Endpoints Ideal to quickly wiring up and endpoint with minimal footprint. Great for low complexity endpoints.\nHybrid Endpoints Best of both worlds, create a fast endpoint but delegate logic to a different class (IRequestHandler), at the cost of a little extra boilerplate.\nMediator Endpoints Delegate endpoint logic to a class, great for constructor injection and complex endpoints."},"title":"Create an Endpoint"},"/docs/create-an-endpoint/fast-endpoints/":{"data":{"":"","#":"Note: In this section we will use the default inbuilt HTTP/1.1 protocol handler.\nCreate a Fast Endpoint var builder = WiredApp.CreateBuilder(); // Create a default builder, assumes HTTP/1.1 var app = builder .Port(5000) // Configured to http://localhost:5000 .MapGet(\"/quick-start\", scope =\u003e async httpContext =\u003e { // Your endpoint logic here // Manually respond a 200 OK with no content await httpContext .SendAsync(\"HTTP/1.1 200 OK\\r\\nContent-Length:0\\r\\nContent-Type: application/json\\r\\nConnection: keep-alive\\r\\n\\r\\n\"u8.ToArray()); }) .Build(); await app.RunAsync(); You can also use the PipeWriter directly\n.MapGet(\"/quick-start\", scope =\u003e async httpContext =\u003e { await httpContext .Writer.WriteAsync(\"HTTP/1.1 200 OK\\r\\nContent-Length:0\\r\\nContent-Type: application/json\\r\\nConnection: keep-alive\\r\\n\\r\\n\"u8.ToArray()); }) WriteAsync will Write() and FlushAsync(), use Write() if you need to write multiple times and flush at the end.\nWrite() is sync and accepts ReadOnlySpan\n.MapGet(\"/quick-start\", scope =\u003e async httpContext =\u003e { httpContext .Writer.Write(\"HTTP/1.1 200 OK\\r\\n\"u8); httpContext .Writer.Write(\"Content-Length:0\\r\\n\"u8); httpContext .Writer.Write(\"Content-Type: application/json\\r\\nConnection: keep-alive\\r\\n\\r\\n\"u8); await httpContext.Writer.FlushAsync(); }) Alternatively, use the inbuilt handler’s middleware to process the http response automatically.\nvar builder = WiredApp.CreateBuilder(); // Create a default builder, assumes HTTP/1.1 var app = builder .Port(5000) // Configured to http://localhost:5000 .MapGet(\"/quick-start\", scope =\u003e async httpContext =\u003e { // Your endpoint logic here httpContext .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent( new { Name = \"Toni\", Age = 18 }, JsonSerializerOptions.Default)); }) .Build(); await app.RunAsync(); "},"title":"Fast Endpoints"},"/docs/create-an-endpoint/mediator/":{"data":{"":"Mediator feature allows a better code structuring for complex endpoint implementations, as well as a more streamlined dependency resolution (see 3. Dependency Injection chapter).\nWhile it can be more convenient than fast endpoints, keep in mind that it’s performance is slightly worse due to the IRequestHandler/IContextHandler resolution overhead.\nJust like mediator like patterns, it is posdsible to set up IPipelineBehavior behaviors, see 4. Pipeline Behaviors chapter."},"title":"Mediator"},"/docs/create-an-endpoint/mediator/hybrid-endpoints/":{"data":{"":"","#":"Note: In this section we will use the default inbuilt HTTP/1.1 protocol handler.\nHybrid endpoints are a mix between fast and mediator endpoints, ideally if you want to define your endpoint logic in a different class while still using fast endpoints.\n( ... ) var app = builder // Call this to tell the builder to scan assembly and // register your IRequestHandler types .AddHandlers(Assembly.GetExecutingAssembly()) .Port(5000) // Configured to http://localhost:5000 .MapGet(\"/hybrid-endpoint\", scope =\u003e async context =\u003e { // Resolve your IRequestHandler var requestHandler = scope .GetRequiredService\u003cIRequestHandler\u003cRequestQuery, RequestResult\u003e\u003e(); // Execute it var result = await requestHandler .Handle(new RequestQuery(), context.CancellationToken); // Pass its result top be processed by the response middleware, // optionally deal with the response yourself without calling .Respond() context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(result, JsonSerializerOptions.Default)); }) ( ... ) public class RequestHandlerExample : IRequestHandler\u003cRequestQuery, RequestResult\u003e { public async Task\u003cRequestResult\u003e Handle(RequestQuery query, CancellationToken cancellationToken) { await Task.Delay(0, cancellationToken); // Do work return new RequestResult(\"Toni\", \"Mars\"); } } public record RequestQuery() : IRequest\u003cRequestResult\u003e; public record RequestResult(string Name, string Address); The fast endpoint is created to resolve the IRequestHandler.\nThe IRequestHandler does not know about http method, route or IContext in general, it is abstracted away to deal with business logic.\nJust like your typical mediator pattern, it takes in a Query/Command.\nVoid return overload IRequestHandler Just an overload when request handlers dont need to return anything.\n( ... ) var app = builder // Call this to tell the builder to scan assembly and // register your IRequestHandler types .AddHandlers(Assembly.GetExecutingAssembly()) .Port(5000) // Configured to http://localhost:5000 .MapGet(\"/hybrid-endpoint\", scope =\u003e async context =\u003e { // Resolve your IRequestHandler var requestHandler = scope .GetRequiredService\u003cIRequestHandler\u003cRequestQuery\u003e\u003e(); // Execute it await requestHandler .Handle(new RequestQuery(), context.CancellationToken); // NoContent response context .Respond() .Status(ResponseStatus.NoContent); }) ( ... ) public class RequestHandlerExample : IRequestHandler\u003cRequestQuery\u003e { public async Task Handle(RequestQuery query, CancellationToken cancellationToken) { await Task.Delay(0, cancellationToken); // Do work } } public record RequestQuery() : IRequest; "},"title":"2.2.1 - Hybrid Endpoints"},"/docs/create-an-endpoint/mediator/mediator-endpoints/":{"data":{"":"Note: In this section we will use the default inbuilt HTTP/1.1 protocol handler.\nMediator endpoints do not require the creation of a fast endpoint.\nUnlike hybrid endpoints that implement IRequestHandler, mediator endpoints implement IContextHandler since the context is passed directly to the Handle method.\nIn short, the logic that would be inside the fast endpoint, is now in the Handle method.\n( ... ) var app = builder // Call this to tell the builder to scan assembly and // register your IContextHandler types .AddHandlers(Assembly.GetExecutingAssembly()) .Port(5000) // Configured to http://localhost:5000 ( ... ) // The routing is defined with the RouteAttribute, // this is mandatory or else it won't be routed [Route(\"GET\", \"/mediator-endpoint\")] public class ContextHandlerExample() // Http11Context is used as we are using the default inbuilt IHttpHandler // Adapt to your custom handler if the case : IContextHandler\u003cHttp11Context\u003e { public async Task Handle(Http11Context context, CancellationToken cancellationToken) { await Task.Delay(0, cancellationToken); // Do work // Again, using the middleware response pipeline is optional here context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(new { Name = \"Toni\" }, JsonSerializerOptions.Default)); } } "},"title":"2.2.2 - Mediator Endpoints"},"/docs/custom-response-content/":{"data":{"":"","#":"Note: this feature is part of the Wired.IO default IHttpHandler middleware pipeline (Response Middleware) See 1. Create a Builder to learn more about IHttpHandler.\nWhen using the response middleware, for example:\n// Example with fast endpoint builder .MapGet(\"/route\", scope =\u003e context =\u003e { context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(new { Name = \"Example\" }, JsonSerializerOptions.Default)); }) This will create an IResponse in the IContext (context) that will be processed by the ResponseMiddleware, if IResponse is null, the middleware is skipped (for the cases when the user handles the response himself).\nCreate a custom IResponseContent With custom IResponseContent it is possible to gain some more control over the response content while using response middleware.\nChunked Transfer Encoding Content-Length-Based Response Chunked responses can be handy when content length is unknown or make data availabe to the client without having to wait for the full content.\npublic class CustomResponseContent(ReadOnlyMemory\u003cbyte\u003e data) : IResponseContent { // Set Length to null to let the response middleware know to use // transfer chunked encoding // If Length is set, the Content-Length will be set to its value public ulong? Length =\u003e null!; public ValueTask\u003culong?\u003e CalculateChecksumAsync() =\u003e new((ulong)data.GetHashCode()); // Define the chunked Write public async ValueTask WriteAsync(ChunkedPipeWriter writer, uint bufferSize) { // Access the underlying PipeWriter if need // ChunkedPipeWriter is just a wrapper on PipeWriter // to write in chunks (add chunk size and chunk terminators) var underlyingPipeWriter = writer.GetPipeWriter(); // Send first chunk and flush it so that receiver can already process it // For NET9.0+ you can use await writer.WriteAsync(data) // already flushes writer.Write(data.Span); await writer.FlushAsync(); // Send second chunk writer.Write(\"Additional information\"u8); // Send chunked response terminator and flush it writer.Finish(); await writer.FlushAsync(); } // Length is null, this method will never be used public void Write(PlainPipeWriter writer, uint bufferSize) { throw new NotImplementedException(); } } This is what the response looks like from client side:\nHTTP/1.1 200 OK\rServer: Wired.IO\rDate: Mon, 07 Jul 2025 17:10:18 GMT\rContent-Type: text/plain\rTransfer-Encoding: chunked\rD\rresponse data\r16\rAdditional information\r0 When using content length based response, Length property cannot be null.\npublic class CustomResponseContent(ReadOnlyMemory\u003cbyte\u003e data) : IResponseContent { // Set the Length property public ulong? Length =\u003e (ulong)data.Length; public ValueTask\u003culong?\u003e CalculateChecksumAsync() =\u003e new((ulong)data.GetHashCode()); // Length is not null, this method will never be used public async ValueTask WriteAsync(ChunkedPipeWriter writer, uint bufferSize) { throw new NotImplementedException(); } public async ValueTask WriteAsync(PipeWriter writer, uint bufferSize) { // For NET9.0+ you can use await writer.WriteAsync(data) // already flushes writer.Write(data.Span); await writer.FlushAsync(); } } This is what the response looks like on the client side:\nHTTP/1.1 200 OK\rServer: Wired.IO\rDate: Mon, 07 Jul 2025 21:23:49 GMT\rContent-Type: text/plain\rContent-Length: 13\rresponse data "},"title":"Custom Response Content"},"/docs/dependency-injection/":{"data":{"":"","#":"Wired.IO supports dependency injection across the entire framework.\nRegistering a service Register @ Wired.IO IServiceCollection\n( ... ) builder.Services.AddScoped\u003cDependencyService\u003e(); ( ... ) builder.Build(); // Builds IHostBuilder into IHost ( ... ) public class DependencyService(ILogger\u003cDependencyService\u003e logger) : IDisposable { public void Handle() =\u003e logger.LogInformation($\"{nameof(DependencyService)} was handled.\"); public void Dispose() =\u003e logger.LogInformation($\"{nameof(DependencyService)} was disposed.\"); } Fast EndpointsHybrid EndpointsMediator Endpoints Fast Endpoints Resolve dependencies directly from scope (IServiceProvider).\nscope is AsyncServiceScope meaning that by the end of the request, all scoped lifetime dependencies resolved during the request, will be disposed.\n.MapGet(\"/fast-endpoint\", scope =\u003e async httpContext =\u003e { var dependency = scope.GetRequiredService\u003cDependencyService\u003e(); dependency.Handle(); // Use the service httpContext .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent( new { Name = \"Alice\", Age = 30 }, JsonSerializerOptions.Default)); }) Hybrid Endpoints Resolve dependencies directly from scope\n( ... ) .MapGet(\"/hybrid-endpoint\", scope =\u003e async context =\u003e { // Resolve the IRequestHandler var requestHandler = scope.GetRequiredService\u003cIRequestHandler\u003cRequestQuery, RequestResult\u003e\u003e(); var result = await requestHandler.Handle(new RequestQuery(), context.CancellationToken); context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(result, JsonSerializerOptions.Default)); }) .Build(); ( ... ) //@ IRequestHandler // Injecting DependencyService @ constructor public class RequestHandlerExample(DependencyService dependencyService) : IRequestHandler\u003cRequestQuery, RequestResult\u003e { public async Task\u003cRequestResult\u003e Handle(RequestQuery request, CancellationToken cancellationToken) { // Execute injected dependency logic dependencyService.Handle(); return new RequestResult(\"Toni\", \"Mars\"); } } public record RequestQuery() : IRequest\u003cRequestResult\u003e; public record RequestResult(string Name, string Address); Mediator Endpoints Inject dependencies from the constructor or IContext.Scope.ServiceProvider\n[Route(\"GET\", \"/mediator-endpoint\")] public class ContextHandlerExample(DependencyService service) : IContextHandler\u003cHttp11Context\u003e { public async Task Handle(Http11Context context, CancellationToken cancellationToken) { // Can also resolve from context // var service = context.Scope.ServiceProvider.GetRequiredService\u003cDependencyService\u003e(); // This would be consider anti patternish so avoid. await Task.Delay(0, cancellationToken); // Do work service.Handle(); context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(new { Name = \"Toni\" }, JsonSerializerOptions.Default)); } } Resolving dependencies for Middleware and IPipelineBehaviors For Middleware, resolve directly from scope, see 3. Adding Middleware chapter.\nFor IPipelineBehaviors, resolve directly from constructor or context.scope."},"title":"Dependency Injection"},"/docs/dev-notes/":{"data":{"":"In this documentation you can find instructions in how to use and take advantage of Wired.IO. In many of the code snipets you will find “( … )” meaning usually some boiler plate is missing in the example, refer to previous sections when in doubt. The preferred order to create a Wired.IO webserver is create the builder, register builder services (@ builder.Services) and then builder configs such as fast endpoints, Tls, Port, Endpoint, etc, followed by .Build() and running or starting it, depending whether you want to block or not.\nWired.IO webservers can be used in standalone or embedded with existing applications, when embedded with existing applications, you can integrating the existing IServiceCollectin and IServiceProvider in your Wired.IO webserver to share the same IoC container. See Embedding with Existing Applications section for more information.\nIf you need help or any clarification don’t hesitate in contacting us via our discord that you can find at the top if this website.\n// Create the Builder var builder = WiredApp.CreateBuilder(); // Register Services, Events handlers etc.. builder.Services .AddScoped\u003cDependencyService\u003e() .AddWiredEventHandler\u003cExampleWiredEvent, ExampleWiredEventHandler\u003e() .AddScoped(typeof(IPipelineBehavior\u003c,\u003e), typeof(ExampleBehavior\u003c,\u003e)); // Builder configurations builder .AddHandlers(Assembly.GetExecutingAssembly()) // If using hybrid or mediator endpoints .Port(5000) .MapGet(\"/quick-start\", scope =\u003e async httpContext =\u003e { httpContext .Respond() .Status(ResponseStatus.Ok) .Type(\"text/plain\") .Content(new StringContent(\"Hello!\")); }); // Create and start/run the app var app = builder.Build(); await app.RunAsync(); "},"title":"Introduction"},"/docs/embedding-with-existing-host/":{"data":{"":"One of the major features of Wired.IO when compared with ASP.NET Core is the possibility of embdedding it in any existing .NET application from console apps to Winforms, WPF, MAUI, AvaloniaUI you name it.\nWired.IO can easily be integrated into the existing app’s IServiceCollection, resolving services directly from it.\nYou can find below a practical example embedding Wired.IO into a .NET MAUI Application, allowing fully integration of a webserver and your UI like having your UI elements reacting to http requests.\nThis capability enables your app to automatically react to any incoming http requests from either external machines or other applications running in the same machine.\nusing CommunityToolkit.Mvvm.ComponentModel; using Microsoft.Extensions.Logging; using Wired.IO.App; using Wired.IO.Protocol.Response; using StringContent = Wired.IO.Http11.Response.Content.StringContent; namespace EmbeddedWired; public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); fonts.AddFont(\"OpenSans-Semibold.ttf\", \"OpenSansSemibold\"); }); #if DEBUG builder.Logging.AddDebug(); #endif // Register the MainPage and MainViewModel, // Note: MainPage BindingContext is set to MainViewModel builder.Services.AddSingleton\u003cMainPage\u003e(); builder.Services.AddSingleton\u003cMainViewModel\u003e(); var wiredBuilder = WiredApp // Default Wired Http/1.1 builder .CreateBuilder() .Port(5000) // Embedd your existing IServiceCollection .EmbedServices(builder.Services) .MapGet(\"/route\", scope =\u003e context =\u003e { var mainViewModel = scope.GetRequiredService\u003cMainViewModel\u003e(); mainViewModel.Title = \"Embedded Wired - Route\"; // Send response here context .Respond() .Status(ResponseStatus.Ok) .Content(new StringContent(\"UI updated\")) .Type(\"plain/text\"); }); var mauiApp = builder.Build(); var wiredApp = wiredBuilder.Build(mauiApp.Services); wiredApp.Start(); return mauiApp; } } public partial class MainViewModel : ObservableObject { [ObservableProperty] private string _title = \"Embedded Wired\"; [ObservableProperty] private string _message = \"Welcome to Embedded Wired!\"; } "},"title":"Embedding with Existing Applications"},"/docs/logging/":{"data":{"":"","#":"Wired.IO implements ILoggingFactory with its default parameters\nprivate static void DefaultLoggingBuilder(ILoggingBuilder loggingBuilder) { loggingBuilder .ClearProviders() #if DEBUG .SetMinimumLevel(LogLevel.Debug) #else .SetMinimumLevel(LogLevel.Information) #endif .AddConsole(); } If you want to override this ILoggingFactory, register yours with your logging builder configuration (Microsoft.Extensions.Logging).\n( ... ) builder.Services .AddLogging(loggingBuilder =\u003e { // Configure ILoggingBuilder }) ( ... ) Check official docs at ILoggingBuilder docs to explore configurability.\nInject an ILogger Resolve a ILogger\u003c\u003e anywhere.\nFor fast endpoints and middleware resolve directly from scope.\n// Replace Program with your TCategoryName var logger = scope.GetRequiredService\u003cILogger\u003cProgram\u003e(); Anyhwere else, resolve from constructor.\n// For example in a IRequestHandler public class RequestHandlerExample(ILogger\u003cRequestHandlerExample\u003e logger) : IRequestHandler\u003cRequestQuery, RequestResult\u003e { public async Task\u003cRequestResult\u003e Handle(RequestQuery request, CancellationToken cancellationToken) { logger.LogInformation($\"{nameof(RequestHandlerExample)} was handled.\"); ( ... ) } } "},"title":"Logging"},"/docs/middleware/":{"data":{"":"Note: In this section we will use the default inbuilt HTTP/1.1 protocol handler.\nCreate and register custom middleware to the request handling pipeline, analogous to ASP.NET Core. Note that the middlewares will execute by registration order.\nIn this section let’s create a basic global error handling middleware.\n( ... ) builder.UseMiddleware(scope =\u003e async (context, next) =\u003e { // logger or any dependencies can be resolved using scope var logger = scope.GetRequiredService\u003cILogger\u003cProgram\u003e\u003e(); try { // Execute next in line, could be another middleware or the endpoint await next(context); } // If unhandled exception caught, create an error response // to be processed by the response handling middleware, // the response handling middleware will always run after // any user registered middleware as it is always registered first. catch (Exception e) { logger.LogError(e.Message); context.Respond() .Status(ResponseStatus.InternalServerError) .Type(\"application/json\") .Content( new JsonContent(new { Error = e.Message }, JsonSerializerOptions.Default)); } }) ( ... ) "},"title":"Adding Middleware"},"/docs/pipeline-behaviors/":{"data":{"":"While not the most useful feature as it does not provide anything extra apart from maybe slight better code structure, pipeline behaviors can be attached to the mediator pipeline.\nWhen using hybrid or mediator endpoints it is possible to add IPipelineBehavior behaviors that will execute before or after the endpoint, similar to ASP.NET Core filters.\nIPipelineBehaviors can be configured to run for all endpoints (hybrid or mediator mutually exclusive) or a specific set of endpoints, which is an advantage in comparison with middleware which executes for all endpoints.\nAnother important difference is that pipeline behaviors execute after all middlewares next() call, and before middleware return path. We could say behaviors wrap the endpoint and middleware pipeline wraps the behaviors."},"title":"Pipeline Behaviors"},"/docs/pipeline-behaviors/hybrid/":{"data":{"":"","#":"Adding IPipelineBehavior for Hybrid Enpdoints In hybrid endpoints resolve IRequestDispatcher instead of IRequestHandler.\n( ... ) builder.Services // Register the IPipelineBehavior\u003c,\u003e .AddScoped(typeof(IPipelineBehavior\u003c,\u003e), typeof(ExampleBehavior\u003c,\u003e)) .MapGet(\"/hybrid-endpoint\", scope =\u003e async context =\u003e { // Does not execute behaviors //var requestHandler = scope.GetRequiredService\u003cIRequestHandler\u003cRequestQuery, RequestResult\u003e\u003e(); //var result = await requestHandler.Handle(new RequestQuery(), context.CancellationToken); // Executes behaviors var dispatcher = scope.GetRequiredService\u003cIRequestDispatcher\u003cHttp11Context\u003e\u003e(); // Use the corresponding IContext var result = await dispatcher.Send(new RequestQuery()); context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(result, JsonSerializerOptions.Default)); }) ( ... ) // Define the IPipelineBehavior\u003cTRequest, TResponse\u003e public class ExampleBehavior\u003cTRequest, TResponse\u003e : IPipelineBehavior\u003cTRequest, TResponse\u003e where TRequest : notnull { public async Task\u003cTResponse\u003e Handle(TRequest request, RequestHandlerDelegate\u003cTResponse\u003e next, CancellationToken cancellationToken) { // Execute pre endpoint behavior logic here // Execute next IPipelineBehavior or IRequestHandler return await next(); // Execute post endpoint behavior logic here } } Void response IPipelineBehavior also supports void response just like IRequestHandler\n( ... ) builder.Services .AddScoped(typeof(IPipelineBehaviorNoResponse\u003c\u003e), typeof(ExampleBehavior\u003c\u003e)) .MapGet(\"/hybrid-endpoint\", scope =\u003e async context =\u003e { var dispatcher = scope.GetRequiredService\u003cIRequestDispatcher\u003cHttp11Context\u003e\u003e(); await dispatcher.Send(new RequestQuery(), context.CancellationToken); context .Respond() .Status(ResponseStatus.Ok); }) ( ... ) public class ExampleBehavior\u003cTRequest\u003e : IPipelineBehaviorNoResponse\u003cTRequest\u003e where TRequest : IRequest { public async Task Handle(TRequest request, RequestHandlerDelegate next, CancellationToken cancellationToken) { // Execute pre endpoint behavior logic here // Execute next IPipelineBehavior or IRequestHandler await next(); // Execute post endpoint behavior logic here } } public record RequestQuery() : IRequest; Register a IPipelineBehavior for specific endpoints In the previous example we are registering a pipeline behavior for any type, in the following example a void response IRequestHandler will be used but this applies for both IRequestHandler\u003c\u003e and IRequestHandler\u003c,\u003e.\n.AddScoped(typeof(IPipelineBehavior\u003c,\u003e), typeof(ExampleBehavior\u003c,\u003e) By defining the TRequest, we can filter which endpoints execute the pipeline behavior.\n( ... ) builder.Services .AddScoped(typeof(IPipelineBehaviorNoResponse\u003cRequestQuery\u003e), typeof(ExampleBehavior\u003cRequestQuery\u003e)) .MapGet(\"/hybrid-endpoint\", scope =\u003e async context =\u003e { var dispatcher = scope.GetRequiredService\u003cIRequestDispatcher\u003cHttp11Context\u003e\u003e(); // Sends for RequestQuery TRequest await dispatcher.Send(new RequestQuery(), context.CancellationToken); context .Respond() .Status(ResponseStatus.Ok); }) ( ... ) public class RequestHandlerExample : IRequestHandler\u003cRequestQuery\u003e { public async Task Handle(RequestQuery request, CancellationToken cancellationToken) { await Task.Delay(0, cancellationToken); // Do work } } public record RequestQuery() : IRequest; public class ExampleBehavior\u003cTRequest\u003e : IPipelineBehaviorNoResponse\u003cRequestQuery\u003e where TRequest : IRequest { public async Task Handle(RequestQuery request, RequestHandlerDelegate next, CancellationToken cancellationToken) { // Execute pre endpoint behavior logic here await next(); // Execute post endpoint behavior logic here } } "},"title":"Hybrid Endpoints"},"/docs/pipeline-behaviors/mediator/":{"data":{"":"","#":"Adding IPipelineBehavior for Mediator Endpoints For mediator endpoints, the framework already resolves the IRequestDispatcher\n// Register the IPipelineBehavior\u003c\u003e builder.Services.AddScoped(typeof(IPipelineBehavior\u003c\u003e), typeof(ExampleBehavior\u003c\u003e)); ( ... ) // Define the endpoint [Route(\"GET\", \"/mediator-endpoint\")] public class ContextHandlerExample(DependencyService service) : IContextHandler\u003cHttp11Context\u003e { public async Task Handle(Http11Context context, CancellationToken cancellationToken) { await Task.Delay(0, cancellationToken); // Do work service.Handle(); context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(new { Name = \"Toni\" }, JsonSerializerOptions.Default)); } } // Define the IPipelineBehavior\u003cTContext\u003e public class ExampleBehavior\u003cTContext\u003e : IPipelineBehavior\u003cTContext\u003e where TContext : IContext { public async Task Handle(TContext context, RequestHandlerDelegate next, CancellationToken cancellationToken) { // Execute pre endpoint behavior logic here // Execute next IPipelineBehavior or IContextHandler await next(); // Execute post endpoint behavior logic here } } or define TContext if known, this can also be taken advantage to filter behaviors on TContext.\n// Register the IPipelineBehavior\u003c\u003e builder.Services.AddScoped(typeof(IPipelineBehavior\u003cHttp11Context\u003e), typeof(ExampleBehavior)); ( ... ) // Define the endpoint [Route(\"GET\", \"/mediator-endpoint\")] public class ContextHandlerExample(DependencyService service) : IContextHandler\u003cHttp11Context\u003e { public async Task Handle(Http11Context context, CancellationToken cancellationToken) { await Task.Delay(0, cancellationToken); // Do work service.Handle(); context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(new { Name = \"Toni\" }, JsonSerializerOptions.Default)); } } // Define the IPipelineBehavior\u003cTContext\u003e public class ExampleBehavior : IPipelineBehavior\u003cHttp11Context\u003e { public async Task Handle(Http11Context context, RequestHandlerDelegate next, CancellationToken cancellationToken) { // Execute pre endpoint behavior logic here // Execute next IPipelineBehavior or IContextHandler await next(); // Execute post endpoint behavior logic here } } "},"title":"Mediator Endpoints"},"/docs/security-tls/":{"data":{"":"Wired.IO supports out of the box secure endpoints.\nVisit SslServerAuthenticationOptions Class for detailed documentation.\n( ... ) var app = builder .UseTls(new SslServerAuthenticationOptions { // Define your SSL options here // Such as load server certificate, // Load CA certificate, // RemoteCertificateValidationCallback for mutual TLS, etc. }) ( ... ) "},"title":"Security (TLS)"},"/docs/static-resources/":{"data":{"":"Using the default IHttpHandler (see 1. Create a Builder) it is very straightforward to serve static resources.\nThe static resources build action must be Embedded Resource.\nWhen creating the builder pass the assembly in which the resources are contained as the full embeddedd resource path.\nvar builderWithParameters = App.CreateBuilder(() =\u003e new WiredHttp11\u003cHttp11Context\u003e(new Http11HandlerArgs( UseResources: true, // Full resources path for example: // If the resources are stored in the project root just pass the Assembly name // If the resources are stored in side a folder, pass the full pass e.g. MyAssemblyName.FolderName ResourcesPath: \"MyAssemblyName\", // The assembly where the resources are stored ResourcesAssembly: Assembly.GetExecutingAssembly())) ); All set, to test this just send a request with the resource name as route for example: http://localhost:5000/index.html"},"title":"Static Resources"},"/docs/websockets/":{"data":{"":"Wired.IO internal default http handler (WiredHttp11) implements RFC 6455.\nWhen using a custom IHttpHandler, you must implement it yourself. Check 1. Create a Builder section to learn more about IHttpHandler.\nWhile using fast endpoints is the preferred option to use websockets, it is not mandatory, anywhere where you have access to the IContext you can take advantage of the IContext extension methods to write to or read from the websocket.\nNote: when using websockets Wired.IO’s WiredHttp11 is expecting a ws:// request or wss:// if tls is enabled.\nCheck 8. Security (TLS) chapter to learn more about how to use Transport Layer Security.\n( ... ) // ws://{hostname:portnumber}/websocket // or // wss://{hostname:portnumber}/websocket // if TLS is enabled .MapGet(\"/websocket\", scope =\u003e async context =\u003e { // Optional, rent an array pool or just allocate a new array. var arrayPool = ArrayPool\u003cbyte\u003e.Shared; var buffer = arrayPool.Rent(8192); while (true) { // Use IContext extensions WsReadAsync and WsSendAsync // to read from and send data to the websocket. (ReadOnlyMemory\u003cbyte\u003e data, WsFrameType wsFrameType) receivedData = await context.WsReadAsync(buffer); if (receivedData.wsFrameType == WsFrameType.Close) break; if (receivedData.data.IsEmpty) break; await context.WsSendAsync(receivedData.Item1, 0x01); } // Optional, return the rented buffer if applicable. arrayPool.Return(buffer); }) ( ... ) "},"title":"Websockets"},"/docs/wired-events/":{"data":{"":"","#":"Wired events, similar to domain events concept provide a scalable, extensible way to trigger side effects, notifications, or further workflows.\nIContext Wired Events Instead of living the the domain entity, wired events live in the IContext which is uniquer for each request.\n// Create a IWiredEvent public class ExampleWiredEvent(string description) : IWiredEvent { public Guid Id { get; } = Guid.NewGuid(); public DateTime OccurredOn { get; } = DateTime.UtcNow; public string Description { get; } = description; } // Create a IWiredEventHandler\u003cin TEvent\u003e where TEvent : IWiredEvent public class ExampleWiredEventHandler(ILogger\u003cExampleWiredEventHandler\u003e logger) : IWiredEventHandler\u003cExampleWiredEvent\u003e { public async Task HandleAsync(ExampleWiredEvent wiredEvent) { // Handle the wired event here logger.LogInformation($\"Handled wired event: {wiredEvent.Description} at {wiredEvent.OccurredOn}\"); } } ( ... ) // Register the IWiredEventHandler in the IoC container builder.Services.AddWiredEventHandler\u003cExampleWiredEvent, ExampleWiredEventHandler\u003e(); ( ... ) // Create wired events that will be handled by the middleware after the request is processed ( ... ) builder .AddWiredEvents(dispatchContextWiredEvents: true) .MapGet(\"/wired-event\", scope =\u003e async context =\u003e { context.AddWiredEvent(new ExampleWiredEvent(\"Creating a wired event\")); // Handle response here.. }) ( ... ) Non IContext Wired Events In many scenarios IContext is not practical to own the wired events such as when creating events in different application layers. For those cases it is possible to manually handle the wired events dispatching. One of the greatest advantage of using wired events is allowing any class to delegate work to be done by a handler that is registeres in the IoC while the class that creates the event itself isn’t.\nThis is specifically useful when working with transactions such as is database access where the database models are entities that cannot inject dependencies in their constructors.\nCreate the wired event, handler and the class that will own the wired events // Create a IWiredEvent public class ExampleWiredEvent(string description) : IWiredEvent { public Guid Id { get; } = Guid.NewGuid(); public DateTime OccurredOn { get; } = DateTime.UtcNow; public string Description { get; } = description; } // Create a IWiredEventHandler\u003cin TEvent\u003e where TEvent : IWiredEvent public class ExampleWiredEventHandler(EmailService emailService, ILogger\u003cExampleWiredEventHandler\u003e logger) : IWiredEventHandler\u003cExampleWiredEvent\u003e { // The handler can inject services from the IoC container public async Task HandleAsync(ExampleWiredEvent wiredEvent) { // Handle the wired event here emailService.SendEmail(\"Something happened\", \"wiredio@gmail.com\"); logger.LogInformation($\"Handled wired event: {wiredEvent.Description} at {wiredEvent.OccurredOn}\"); } } // Create a class that implements IHasWiredEvents public class Entity : IHasWiredEvents { private readonly List\u003cIWiredEvent\u003e _wiredEvents = new(); public IReadOnlyList\u003cIWiredEvent\u003e WiredEvents =\u003e _wiredEvents; public void AddWiredEvent(IWiredEvent wiredEvent) =\u003e _wiredEvents.Add(wiredEvent); public void ClearWiredEvents() =\u003e _wiredEvents.Clear(); public void DoSomething() { // Simulate some operation that generates a wired event // For example, storing it in a database var wiredEvent = new ExampleWiredEvent(\"Entity did something important\"); AddWiredEvent(wiredEvent); } } Register the wired event handler ( ... ) // Register the IWiredEventHandler in the IoC container builder.Services.AddWiredEventHandler\u003cExampleWiredEvent, ExampleWiredEventHandler\u003e(); ( ... ) At the endpoint.. Fast EndpointsHybrid EndpointsMediator Endpoints // Create Entity and manually dispatch the wired events builder // dispatchContextWiredEvents can be set as false // if context wired events are not being used .AddWiredEvents(dispatchContextWiredEvents: false) .MapGet(\"/wired-event\", scope =\u003e async httpContext =\u003e { var entity = new Entity(); entity.DoSomething(); // Handle response here.. // Dispatch wired events, this can be wrapped // in a unit of work pattern or outbox pattern var wiredEventDispatcher = scope .GetRequiredService\u003cFunc\u003cIEnumerable\u003cIWiredEvent\u003e, Task\u003e\u003e(); await wiredEventDispatcher(entity.WiredEvents); entity.ClearWiredEvents(); }) public class RequestHandlerExample(Func\u003cIEnumerable\u003cIWiredEvent\u003e, Task\u003e wiredEventDispatcher) : IRequestHandler\u003cRequestQuery, RequestResult\u003e { public async Task\u003cRequestResult\u003e Handle(RequestQuery request, CancellationToken cancellationToken) { var entity = new Entity(); entity.DoSomething(); await wiredEventDispatcher(entity.WiredEvents); entity.ClearWiredEvents(); return new RequestResult(\"Toni\", \"Mars\"); } } public record RequestQuery() : IRequest\u003cRequestResult\u003e; public record RequestResult(string Name, string Address); ( ... ) builder .AddWiredEvents(dispatchContextWiredEvents: false) .MapGet(\"/wired-event-handler\", scope =\u003e async context =\u003e { var requestHandler = scope.GetRequiredService\u003cIRequestDispatcher\u003cHttp11Context\u003e\u003e(); var result = await requestHandler.Send(new RequestQuery(), context.CancellationToken); context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(result, JsonSerializerOptions.Default)); }) ( ... ) // The most elegant solution [Route(\"GET\", \"/wired-event-handler\")] public class ContextHandlerExample(Func\u003cIEnumerable\u003cIWiredEvent\u003e, Task\u003e wiredEventDispatcher) : IContextHandler\u003cHttp11Context\u003e { public async Task Handle(Http11Context context, CancellationToken cancellationToken) { var entity = new Entity(); entity.DoSomething(); await wiredEventDispatcher(entity.WiredEvents); entity.ClearWiredEvents(); context .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent(new { Name = \"Toni\", Address = \"Mars\" }, JsonSerializerOptions.Default)); } } "},"title":"Wired Events"},"/quick/":{"data":{"":"","add-logging-and-inject-a-dependency#Add logging and inject a dependency":"This section contains quick basic examples to get you started, for advanced usage such as configuring TLS, use websockets, add middleware, etc, please check the Docs.\nInclude the Wired.IO package in your project. dotnet add package Wired.IO --version 9.1.0 Wire up a basic endpoint No middlewares, directly respond to the socket’s NetworkStream using PipeWriter.\nusing Wired.IO.App; using Wired.IO.Http11.Context; var builder = WiredApp.CreateBuilder(); // Create a default builder, assumes HTTP/1.1 var app = builder .Port(5000) // Configured to http://localhost:5000 .MapGet(\"/quick-start\", scope =\u003e async httpContext =\u003e { await httpContext .SendAsync(\"HTTP/1.1 200 OK\\r\\nContent-Length:0\\r\\nContent-Type: application/json\\r\\nConnection: keep-alive\\r\\n\\r\\n\"u8.ToArray()); }) .Build(); await app.RunAsync(); Using response building middleware to correctly send proper response headers and content\nusing System.Text.Json; using Wired.IO.App; using Wired.IO.Http11.Response.Content; using Wired.IO.Protocol.Response; var builder = WiredApp.CreateBuilder(); // Create a default builder, assumes HTTP/1.1 var app = builder .Port(5000) // Configured to http://localhost:5000 .MapGet(\"/quick-start\", scope =\u003e httpContext =\u003e { httpContext .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent( new { Name = \"Toni\", Age = 18 }, JsonSerializerOptions.Default)); }) .Build(); await app.RunAsync(); Add logging and inject a dependency Just like ASP.NET, scoped dependencies are disposed by the end of the request processing.\nusing System.Text.Json; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using Wired.IO.App; using Wired.IO.Http11.Response.Content; using Wired.IO.Protocol.Response; var builder = WiredApp.CreateBuilder(); // Create a default builder, assumes HTTP/1.1 builder.Services .AddLogging(loggingBuilder =\u003e { loggingBuilder.ClearProviders(); loggingBuilder.AddConsole(); loggingBuilder.SetMinimumLevel(LogLevel.Information); // Set the minimum log level }) .AddScoped\u003cDependencyService\u003e(); var app = builder .Port(5000) // Configured to http://localhost:5000 .MapGet(\"/quick-start\", scope =\u003e async httpContext =\u003e { var dependency = scope.GetRequiredService\u003cDependencyService\u003e(); dependency.Handle(); // Use the service httpContext .Respond() .Status(ResponseStatus.Ok) .Type(\"application/json\") .Content(new JsonContent( new { Name = \"Alice\", Age = 30 }, JsonSerializerOptions.Default)); }) .Build(); await app.RunAsync(); class DependencyService(ILogger\u003cDependencyService\u003e logger) : IDisposable { public void Handle() =\u003e logger.LogInformation($\"{nameof(DependencyService)} was handled.\"); public void Dispose() =\u003e logger.LogInformation($\"{nameof(DependencyService)} was disposed.\"); } ","include-the-wiredio-package-in-your-project#Include the Wired.IO package in your project.":"","wire-up-a-basic-endpoint#Wire up a basic endpoint":""},"title":"⚡ Let's get you wired up!"}}